{"version":3,"sources":["../../../../source/lib/style/classes/border.js"],"names":[],"mappings":"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","file":"border.js","sourcesContent":["const utils = require('../../utils.js');\nconst types = require('../../types/index.js');\nconst _ = require('lodash');\nconst xmlbuilder = require('xmlbuilder');\nconst CTColor = require('./ctColor.js');\n\nclass BorderOrdinal {\n    constructor(opts) {\n        opts = opts ? opts : {};\n        if (opts.color !== undefined) {\n            this.color = new CTColor(opts.color);\n        }\n        if (opts.style !== undefined) {\n            this.style = types.borderStyle.validate(opts.style) === true ? opts.style : null;\n        }\n    }\n\n    toObject() {\n        let obj = {};\n        if (this.color !== undefined) {\n            obj.color = this.color.toObject();\n        }\n        if (this.style !== undefined) {\n            obj.style = this.style;\n        }\n        return obj;\n    }\n}\n\nclass Border {\n    /** \n     * @class Border\n     * @desc Border object for Style\n     * @param {Object} opts Options for Border object\n     * @param {Object} opts.left Options for left side of Border\n     * @param {String} opts.left.color HEX represenation of color\n     * @param {String} opts.left.style Border style\n     * @param {Object} opts.right Options for right side of Border\n     * @param {String} opts.right.color HEX represenation of color\n     * @param {String} opts.right.style Border style\n     * @param {Object} opts.top Options for top side of Border\n     * @param {String} opts.top.color HEX represenation of color\n     * @param {String} opts.top.style Border style\n     * @param {Object} opts.bottom Options for bottom side of Border\n     * @param {String} opts.bottom.color HEX represenation of color\n     * @param {String} opts.bottom.style Border style\n     * @param {Object} opts.diagonal Options for diagonal side of Border\n     * @param {String} opts.diagonal.color HEX represenation of color\n     * @param {String} opts.diagonal.style Border style\n     * @param {Boolean} opts.outline States whether borders should be applied only to the outside borders of a cell range\n     * @param {Boolean} opts.diagonalDown States whether diagonal border should go from top left to bottom right\n     * @param {Boolean} opts.diagonalUp States whether diagonal border should go from bottom left to top right\n     * @returns {Border}\n     */\n    constructor(opts) {\n        opts = opts ? opts : {};\n        this.left;\n        this.right;\n        this.top;\n        this.bottom;\n        this.diagonal;\n        this.outline;\n        this.diagonalDown;\n        this.diagonalUp;\n\n        Object.keys(opts).forEach((opt) => {\n            if (['outline', 'diagonalDown', 'diagonalUp'].indexOf(opt) >= 0) {\n                if (typeof opts[opt] === 'boolean') {\n                    this[opt] = opts[opt];\n                } else {\n                    throw new TypeError('Border outline option must be of type Boolean');\n                }\n            } else if (['left', 'right', 'top', 'bottom', 'diagonal'].indexOf(opt) < 0) {  //TODO: move logic to types folder\n                throw new TypeError(`Invalid key for border declaration ${opt}. Must be one of left, right, top, bottom, diagonal`);\n            } else {\n                this[opt] = new BorderOrdinal(opts[opt]);\n            }\n        });\n    }\n\n    /** \n     * @func Border.toObject\n     * @desc Converts the Border instance to a javascript object\n     * @returns {Object}\n     */\n    toObject() {\n        let obj = {};\n        obj.left;\n        obj.right;\n        obj.top;\n        obj.bottom;\n        obj.diagonal;\n\n        if (this.left !== undefined) {\n            obj.left = this.left.toObject();\n        }\n        if (this.right !== undefined) {\n            obj.right = this.right.toObject();\n        }\n        if (this.top !== undefined) {\n            obj.top = this.top.toObject();\n        }\n        if (this.bottom !== undefined) {\n            obj.bottom = this.bottom.toObject();\n        }\n        if (this.diagonal !== undefined) {\n            obj.diagonal = this.diagonal.toObject();\n        }\n        typeof this.outline === 'boolean' ? obj.outline = this.outline : null;\n        typeof this.diagonalDown === 'boolean' ? obj.diagonalDown = this.diagonalDown : null;\n        typeof this.diagonalUp === 'boolean' ? obj.diagonalUp = this.diagonalUp : null;\n\n        return obj;\n    }\n\n    /**\n     * @alias Border.addToXMLele\n     * @desc When generating Workbook output, attaches style to the styles xml file\n     * @func Border.addToXMLele\n     * @param {xmlbuilder.Element} ele Element object of the xmlbuilder module\n     */\n    addToXMLele(borderXML) {\n        let bXML = borderXML.ele('border');\n        if (this.outline === true) {\n            bXML.att('outline', '1');\n        }\n        if (this.diagonalUp === true) {\n            bXML.att('diagonalUp', '1');\n        }\n        if (this.diagonalDown === true) {\n            bXML.att('diagonalDown', '1');\n        }\n\n        ['left', 'right', 'top', 'bottom', 'diagonal'].forEach((ord) => {\n            let thisOEle = bXML.ele(ord);\n            if (this[ord] !== undefined) {\n                if (this[ord].style !== undefined) {\n                    thisOEle.att('style', this[ord].style);\n                }\n                if (this[ord].color instanceof CTColor) {\n                    this[ord].color.addToXMLele(thisOEle);\n                }\n            }\n        });\n    }\n}\n\nmodule.exports = Border;"]}